==============
Tutorial
==============

RAET is written in python. RAET uses Stack objects.
There are currently two types of RAET Stacks.

- A RoadStack provides communication between IP hosts via UDP sockets
- A LaneStack provides communication between processes on the same host via Unix Domain Sockets (UXD) on unix or mail slots on windows.

Although a RoadStack has a flexible set of configuration parameters,
it tries to use intelligent defaults where ever possible.

The following python snippet shows how to create a RoadStack.

.. code-block:: python

    import raet
    alpha = raet.road.stacking.RoadStack()


This will create a stack with an autogenerated unique name and the default
host address which is listening on any local IP interface and port 7530.

.. code-block:: bash

    >>> alpha.ha
       ('0.0.0.0', 7530)

A RoadStack will persist or save to disk some of its parameters. This is so
that if the system goes down, it can resume using the persisted data.
The default location for the persisted data is in /tmp on unix. If the user
does not have write permissions to /tmp then the .raet folder in the user's home
directory is used.

.. code-block:: bash
    >>> alpha.keep.dirpath
       '/Users/username/.raet/keep/alpha'

To clear the persisted data call:

.. code-block:: bash
    >>> alpha.keep.clearAllDir()

A different name or a host address can be assigned at creation time.
To create another RoadStack just provide it with a unique name and host address.

In order for two RoadStacks to communicate one with another. They need to be connected.
By default RAET uses elliptic curve cryptography to sign and encrypt messages.
This requires that the two RoadStacks exchange keys and perform a handshake.
Each RoadStack has an .auto accept attribute that governs how it will accept keys.
The auto accept has three modes, these are: Never, Once, and Always. For the
purposes of this tutorial we will use the least restrictive mode which is always.
The default is the most restrictive which is never.
If two RoadStack have never been connected before and have not exchanged keys then
they may perform what is called a vacuous join handshake to exhange keys. The main
parameter, if True, will allow that RoadStack to accept a vacuous join handshake
from another RoadStack.

The first step for one RoadStack to initiate the formation of a connection with
another RoadStack is for the RoadStack to add a RemoteEstate to its list of estates.
In the RAET metaphor, an estate represents a host on a UDP channel.

Another important concept to understand about a RoadStack is that it uses a
non-blocking UDP socket. This means that the socket must be repeatedly polled.
Non-blocking sockets makes RAET compatible with non-blocking concurrency frameworks.
RAET is  intended to be used with Ioflo, a non blocking flow based programming framework.
But RAET can be used with other non-blocking io python frameworks especially those
that use yield (generators).  One can easily service the non-blocking io with a
'busy loop' when not using a framework.

The following code will create two roadstacks and perform a vacuous handshake
to exchange keys. It employs a busy loop to service the non-blocking io. At the
end it closes the UDP sockets and clears the persistence files. In a real application
the closing and clearing should not happen until exiting the application.

.. code-block:: python

    '''
    RAET Tutorial Example
    '''
    import time

    import raet
    from raet import raeting

    def example():
        alpha = raet.road.stacking.RoadStack(name='alpha',
                                             ha=('0.0.0.0', 7531),
                                             auto=raeting.autoModes.always)

        beta = raet.road.stacking.RoadStack(name='beta',
                                             ha=('0.0.0.0', 7532),
                                             main=True,
                                             auto=raeting.autoModes.always)

        remote = raet.road.estating.RemoteEstate(stack=alpha,
                                                 ha=beta.ha)

        alpha.addRemote(remote)

        alpha.join(uid=remote.uid, cascade=True)

        stacks = [alpha, beta]
        while True:
            for stack in stacks:
                stack.serviceAll()
                stack.store.advanceStamp(0.1)
            if all([not stack.transactions for stack in stacks]):
                break
            time.sleep(0.1)

        for stack in stacks:
            stack.server.close()  # close the UDP socket
            stack.keep.clearAllDir()  # clear persisted data

    if __name__ == "__main__":
        example()


The default RAET log lever should print the following to the console.

.. code-block:: bash
    Joiner alpha. Do Join with estate_3181b42bb09b11e4a6136c400891de78 in 1 at 0.0
    Joinent beta. Added new remote name='alpha' nuid='2' fuid='2' ha='('127.0.0.1', 7531)' role='alpha'
    Joinent beta. Do Accept of alpha in 1 at 0.0
    Joiner alpha. Do Ack Accept, Done with beta in 1 at 0.1
    Allower alpha. Do Hello with beta in 2 at 0.1
    Joinent beta. Done with alpha in 1 at 0.1
    Allowent beta. Do Cookie with alpha in 2 at 0.1
    Allower alpha. Do Initiate with beta in 2 at 0.2
    Allowent beta. Do Ack Initiate with alpha in 2 at 0.2
    Allower alpha. Do Ack Final, Done with beta in 2 at 0.3
    Aliver alpha. Do Alive with beta in 3 at 0.3
    Allowent beta. Done with alpha in 2 at 0.3
    Alivent beta. Do ack alive with alpha in 3 at 0.3
    Alivent beta. Done with alpha in 3 at 0.3
    Aliver alpha. Done with beta in 3 at 0.4

