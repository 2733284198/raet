==============
Tutorial
==============

RAET is written in python. RAET uses Stack objects.
There are currently two types of RAET Stacks.

- A RoadStack provides communication between IP hosts via UDP sockets
- A LaneStack provides communication between processes on the same host via Unix Domain Sockets (UXD) on unix or mail slots on windows.

Although a RoadStack has a flexible set of configuration parameters,
it tries to use intelligent defaults where ever possible.

The following python snippet shows how to create a RoadStack.

.. code-block:: python

    import raet
    alpha = raet.road.stacking.RoadStack()


This will create a stack with an autogenerated unique name and the default
host address which is listening on any local IP interface and port 7530.

.. code-block:: bash

    >>> alpha.ha
       ('0.0.0.0', 7530)

A RoadStack will persist or save to disk some of its parameters. This is so
that if the system goes down, it can resume using the persisted data.
The default location for the persisted data is in /tmp on unix. If the user
does not have write permissions to /tmp then the .raet folder in the user's home
directory is used.

.. code-block:: python
    >>> alpha.keep.dirpath
       '/Users/username/.raet/keep/alpha'

To clear the persisted data call:

.. code-block:: bash

    >>> alpha.keep.clearAllDir()

A different name or a host address can be assigned at creation time.
To create another RoadStack just provide it with a unique name and host address.

In order for two RoadStacks to communicate one with another. They need to be connected.
RAET uses elliptic curve cryptography to sign and encrypt messages.
This requires that the two RoadStacks exchange keys and perform a handshake.

Each RoadStack has an .auto accept attribute that governs how it will accept keys.
The auto accept has three modes, these are: never, once, and always. For the
purposes of this tutorial we will use the least restrictive mode which is 'always'.
The default is the most restrictive which is 'never'.

If two RoadStack have never been connected before and have not exchanged keys then
they may perform what is called a vacuous join handshake to exhange keys. The main
parameter, if True, will allow that RoadStack to accept a vacuous join handshake
from another RoadStack.

The first step for one RoadStack to initiate the formation of a connection with
another RoadStack is for that RoadStack to add a RemoteEstate to its list of estates.
In the RAET coding metaphor, an estate represents a host on a UDP channel.

Another important concept to understand about a RoadStack is that it uses a
non-blocking UDP socket. This means that the socket must be repeatedly polled.
Non-blocking sockets makes RAET compatible with non-blocking concurrency frameworks.
RAET is  intended to be used with Ioflo, a non blocking flow based programming framework.
But RAET can be used with other non-blocking I/O python frameworks especially those
that use yield (generators).  When not using a framework, One can easily service
the non-blocking I/O with a'busy loop'.

The following example code will create two roadstacks and perform a vacuous handshake
to exchange keys. It employs a busy loop to service the non-blocking io. At the
end it closes the UDP sockets and clears the persistence files.

In a real application the closing and clearing should not happen until exiting
the application.

.. code-block:: python

    '''
    RAET Tutorial Example
    '''
    import time

    import raet
    from raet import raeting

    def example():
        alpha = raet.road.stacking.RoadStack(name='alpha',
                                             ha=('0.0.0.0', 7531),
                                             auto=raeting.autoModes.always)

        beta = raet.road.stacking.RoadStack(name='beta',
                                             ha=('0.0.0.0', 7532),
                                             main=True,
                                             auto=raeting.autoModes.always)

        remote = raet.road.estating.RemoteEstate(stack=alpha,
                                                 ha=beta.ha)

        alpha.addRemote(remote)

        alpha.join(uid=remote.uid, cascade=True)

        stacks = [alpha, beta]
        while True:
            for stack in stacks:
                stack.serviceAll()
                stack.store.advanceStamp(0.1)
            if all([not stack.transactions for stack in stacks]):
                break
            time.sleep(0.1)

        for stack in stacks:
            stack.server.close()  # close the UDP socket
            stack.keep.clearAllDir()  # clear persisted data

        print("Finished\n")

    if __name__ == "__main__":
        example()


The RAET log should print the following to the console.

.. code-block::

    Joiner alpha. Do Join with estate_3181b42bb09b11e4a6136c400891de78 in 1 at 0.0
    Joinent beta. Added new remote name='alpha' nuid='2' fuid='2' ha='('127.0.0.1', 7531)' role='alpha'
    Joinent beta. Do Accept of alpha in 1 at 0.0
    Joiner alpha. Do Ack Accept, Done with beta in 1 at 0.1
    Allower alpha. Do Hello with beta in 2 at 0.1
    Joinent beta. Done with alpha in 1 at 0.1
    Allowent beta. Do Cookie with alpha in 2 at 0.1
    Allower alpha. Do Initiate with beta in 2 at 0.2
    Allowent beta. Do Ack Initiate with alpha in 2 at 0.2
    Allower alpha. Do Ack Final, Done with beta in 2 at 0.3
    Aliver alpha. Do Alive with beta in 3 at 0.3
    Allowent beta. Done with alpha in 2 at 0.3
    Alivent beta. Do ack alive with alpha in 3 at 0.3
    Alivent beta. Done with alpha in 3 at 0.3
    Aliver alpha. Done with beta in 3 at 0.4
    Finished

What the log shows is that 3 different transactions are completed successfully.
The first transaction is a Join that is composed of a Joiner on the alpha side and
a Joinent on the beta side. The next transaction is an Allow that is composed of
an Allower on the alpha side and an Allowent on the beta side. The final transaction
is an Alive that is composed of an Aliver on the alpha side and an Alivent on the
beta side.

The Join transaction exchanges the signing and long term encryption keys. The
Allow transaction performs a Curve-CP handshake to exchange the short term encryption
keys. The Alive transaction performs a heatbeat to verify that both sides are
communicative and is used to support a presence service in RAET.

In the following example, to stacks will first complete the handshake and each
send a message to each other. The messages will be signed and encrypted.

.. code-block:: python

    '''
    RAET Tutorial Example
    '''
    import time

    import raet
    from raet import raeting

    def example():

        alpha = raet.road.stacking.RoadStack(name='alpha',
                                             ha=('0.0.0.0', 7531),
                                             auto=raeting.autoModes.always)

        beta = raet.road.stacking.RoadStack(name='beta',
                                            ha=('0.0.0.0', 7532),
                                            main=True,
                                            auto=raeting.autoModes.always)

        remote = raet.road.estating.RemoteEstate(stack=alpha,
                                                 ha=beta.ha)

        alpha.addRemote(remote)

        alpha.join(uid=remote.uid, cascade=True)

        stacks = [alpha, beta]
        while True:
            for stack in stacks:
                stack.serviceAll()
                stack.store.advanceStamp(0.1)
            if all([not stack.transactions for stack in stacks]):
                break
            time.sleep(0.1)

        print("Finished Handshake\n")

        msg =  {'subject': 'Example message alpha to beta',
                'content': 'The dict keys in this dict are not special any dict will do.',}

        alpha.transmit(msg, remote.uid)
        while True:
            for stack in stacks:
                stack.serviceAll()
                stack.store.advanceStamp(0.1)
            if all([not stack.transactions for stack in stacks]):
                break
            time.sleep(0.1)

        rx = beta.rxMsgs.popleft()
        print("{0}\n".format(rx))
        print("Finished Message alpha to beta\n")

        msg =  {'subject': 'Example message beta to alpha',
                'content': 'Messages are the core of raet.',}

        beta.transmit(msg, remote.uid)
        while True:
            for stack in stacks:
                stack.serviceAll()
                stack.store.advanceStamp(0.1)
            if all([not stack.transactions for stack in stacks]):
                break
            time.sleep(0.1)

        rx = alpha.rxMsgs.popleft()
        print("{0}\n".format(rx))
        print("Finished Message beta to alpha\n")

        for stack in stacks:
            stack.server.close()  # close the UDP socket
            stack.keep.clearAllDir()  # clear persisted data

        print("Finished\n")

    if __name__ == "__main__":
        example()

The RAET log should print the following to the console.

.. code-block::

    Joiner alpha. Do Join with estate_d68ca540b0a011e4ba4e6c400891de78 in 1 at 0.0
    Joinent beta. Added new remote name='alpha' nuid='2' fuid='2' ha='('127.0.0.1', 7531)' role='alpha'
    Joinent beta. Do Accept of alpha in 1 at 0.0
    Joiner alpha. Do Ack Accept, Done with beta in 1 at 0.1
    Allower alpha. Do Hello with beta in 2 at 0.1
    Joinent beta. Done with alpha in 1 at 0.1
    Allowent beta. Do Cookie with alpha in 2 at 0.1
    Allower alpha. Do Initiate with beta in 2 at 0.2
    Allowent beta. Do Ack Initiate with alpha in 2 at 0.2
    Allower alpha. Do Ack Final, Done with beta in 2 at 0.3
    Aliver alpha. Do Alive with beta in 3 at 0.3
    Allowent beta. Done with alpha in 2 at 0.3
    Alivent beta. Do ack alive with alpha in 3 at 0.3
    Alivent beta. Done with alpha in 3 at 0.3
    Aliver alpha. Done with beta in 3 at 0.4
    Finished Handshake

    Messenger alpha. Do Message Segment 0 with beta in 4 at 0.5
    Messengent beta. Do Ack Done Message on Segment 0 with alpha in 4 at 0.5
    Messengent beta. Complete with alpha in 4 at 0.5
    Messenger alpha. Done with beta in 4 at 0.6
    ({u'content': u'The dict keys in this dict are not special any dict will do.', u'subject': u'Example message alpha to beta'}, u'alpha')

    Finished Message alpha to beta

    Messenger beta. Do Message Segment 0 with alpha in 1 at 0.7
    Messengent alpha. Do Ack Done Message on Segment 0 with beta in 1 at 0.8
    Messengent alpha. Complete with beta in 1 at 0.8
    Messenger beta. Done with alpha in 1 at 0.8
    ({u'content': u'Messages are the core of raet.', u'subject': u'Example message beta to alpha'}, u'beta')

    Finished Message beta to alpha

    Finished


